# ä»¥å¤ªåŠå­˜å‚¨æ§½ï¼ˆStorage Slotï¼‰å®Œæ•´è¯¦è§£

## ğŸ“‹ ä½ çš„ç†è§£è¯„ä¼°

### ä½ æå‡ºçš„ç»“æ„

```rust
pub struct StorageSlot {
    /// åˆçº¦åœ°å€
    pub address: Address,
    
    /// å­˜å‚¨æ§½é”®ï¼ˆ256 ä½ï¼‰
    pub key: U256,
    
    /// å­˜å‚¨æ§½å€¼ï¼ˆ256 ä½ï¼‰
    pub value: U256,
}
```

### è¯„ä¼°ç»“æœ

âœ… **æ¦‚å¿µä¸Šå®Œå…¨æ­£ç¡®ï¼**  
â“ **ä½†åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™ä¸‰ä¸ªå…ƒç´ çš„ç»„ç»‡æ–¹å¼å–å†³äºä½¿ç”¨åœºæ™¯**

---

## ğŸ—ï¸ Reth ä¸­çš„å®é™…å®ç°

### 1. StorageEntry - æœ€å¸¸ç”¨çš„ç»“æ„

**ä½ç½®**: `crates/primitives-traits/src/storage.rs:22`

```rust
/// Account storage entry.
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct StorageEntry {
    /// Storage key (256 bits)
    pub key: B256,      // â† æ³¨æ„ï¼šè¿™é‡Œæ˜¯ B256ï¼Œä¸æ˜¯ U256
    
    /// Value on storage key (256 bits)
    pub value: U256,
}

impl StorageEntry {
    pub const fn new(key: B256, value: U256) -> Self {
        Self { key, value }
    }
}
```

**å…³é”®å·®å¼‚**ï¼š
```
ä½ çš„ç†è§£:
â”œâ”€ address: Address  âœ… æ¦‚å¿µæ­£ç¡®
â”œâ”€ key: U256         âŒ ç±»å‹ä¸åŒï¼ˆReth ç”¨ B256ï¼‰
â””â”€ value: U256       âœ… å®Œå…¨æ­£ç¡®

Reth StorageEntry:
â”œâ”€ address: åˆ†ç¦»å­˜å‚¨ï¼ˆä¸åœ¨è¿™ä¸ªç»“æ„ä¸­ï¼‰
â”œâ”€ key: B256         â† 32 å­—èŠ‚çš„å“ˆå¸Œ/ç´¢å¼•
â””â”€ value: U256       â† 256 ä½çš„å€¼
```

---

## ğŸ” ä¸ºä»€ä¹ˆ address ä¸åœ¨ StorageEntry ä¸­ï¼Ÿ

### æ•°æ®åº“è¡¨ç»“æ„è®¾è®¡

```rust
// crates/storage/db-api/src/tables/mod.rs:393

/// PlainStorageState è¡¨ç»“æ„
table PlainStorageState {
    type Key = Address,        // â† ä¸»é”®ï¼šåˆçº¦åœ°å€
    type SubKey = B256,        // â† å­é”®ï¼šå­˜å‚¨æ§½é”®
    type Value = StorageEntry, // â† å€¼ï¼šStorageEntry { key, value }
}

// å®é™…å­˜å‚¨ç»“æ„ï¼ˆDupSort è¡¨ï¼‰:
// Key      | SubKey | Value
// ---------|--------|------------------
// Address  | B256   | StorageEntry { key: B256, value: U256 }
```

**è¿™æ ·è®¾è®¡çš„åŸå› **ï¼š

```
ä¼˜åŠ¿ 1: ç©ºé—´æ•ˆç‡
â”œâ”€ æ¯ä¸ªåˆçº¦å¯èƒ½æœ‰æ•°åƒä¸ªå­˜å‚¨æ§½
â”œâ”€ ä¸éœ€è¦ä¸ºæ¯ä¸ªæ§½é‡å¤å­˜å‚¨ address
â””â”€ èŠ‚çœç©ºé—´ï¼š20 å­—èŠ‚ Ã— æ§½æ•°é‡

ä¼˜åŠ¿ 2: æŸ¥è¯¢æ•ˆç‡
â”œâ”€ å¯ä»¥å¿«é€Ÿå®šä½æŸä¸ªåˆçº¦çš„æ‰€æœ‰å­˜å‚¨
â”œâ”€ æ”¯æŒèŒƒå›´æŸ¥è¯¢ï¼ˆæŸä¸ªåœ°å€çš„æ‰€æœ‰æ§½ï¼‰
â””â”€ DupSort è¡¨ä¼˜åŒ–

ä¼˜åŠ¿ 3: ç¼“å­˜å‹å¥½
â”œâ”€ æŒ‰åœ°å€åˆ†ç»„ï¼Œå±€éƒ¨æ€§æ›´å¥½
â””â”€ æ›´å®¹æ˜“å®ç° Merkle Patricia Trie

ç¤ºä¾‹æ•°æ®åº“å¸ƒå±€:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Address: 0x1234...                      â”‚
â”‚   â”œâ”€ Slot 0x00...01 â†’ U256(100)        â”‚
â”‚   â”œâ”€ Slot 0x00...02 â†’ U256(200)        â”‚
â”‚   â””â”€ Slot 0x00...03 â†’ U256(300)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Address: 0x5678...                      â”‚
â”‚   â”œâ”€ Slot 0x00...01 â†’ U256(999)        â”‚
â”‚   â””â”€ Slot 0x00...05 â†’ U256(777)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”„ ä¸åŒåœºæ™¯ä¸‹çš„å­˜å‚¨æ§½è¡¨ç¤º

### åœºæ™¯ 1: æ•°æ®åº“å­˜å‚¨ï¼ˆåˆ†ç¦» addressï¼‰

```rust
// PlainStorageState è¡¨
let address = Address::from([0x12; 20]);
let storage_entry = StorageEntry {
    key: B256::from([0x01; 32]),
    value: U256::from(42),
};

// æ’å…¥æ•°æ®åº“
tx.put::<tables::PlainStorageState>(
    address,         // â† ä¸»é”®
    storage_entry    // â† å€¼
)?;

// æŸ¥è¯¢
let value: Option<StorageEntry> = tx
    .cursor_dup_read::<tables::PlainStorageState>()?
    .seek_by_key_subkey(address, storage_entry.key)?;
//                      â†‘         â†‘
//                      ä¸»é”®      å­é”®
```

### åœºæ™¯ 2: REVM æ‰§è¡Œï¼ˆä¸‰å…ƒç»„ï¼‰

```rust
// crates/revm/src/database.rs:126

impl Database for StateProviderDatabase {
    fn storage(
        &mut self,
        address: Address,    // â† åˆçº¦åœ°å€
        index: U256          // â† å­˜å‚¨æ§½ç´¢å¼•
    ) -> Result<U256> {     // â† è¿”å›å€¼
        // å†…éƒ¨ï¼š
        // 1. å°† U256 è½¬æ¢ä¸º B256
        let key = B256::new(index.to_be_bytes());
        
        // 2. æŸ¥è¯¢æ•°æ®åº“
        let storage_entry = self.0.storage(address, key)?;
        
        // 3. è¿”å› value
        Ok(storage_entry.map(|e| e.value).unwrap_or_default())
    }
}

// REVM ä½¿ç”¨ç¤ºä¾‹ï¼ˆåœ¨ EVM æ‰§è¡Œ SLOAD æŒ‡ä»¤æ—¶ï¼‰
let address = contract_address;
let slot = U256::from(0);  // è¯»å–æ§½ 0
let value = evm.db.storage(address, slot)?;
//                         â†‘        â†‘
//                         åœ°å€     æ§½ç´¢å¼•
```

### åœºæ™¯ 3: çŠ¶æ€å˜æ›´è¿½è¸ªï¼ˆåŒ…å« addressï¼‰

```rust
// crates/storage/db-models/src/storage.rs:11

/// StorageBeforeTx - ç”¨äºé™æ€æ–‡ä»¶å­˜å‚¨
pub struct StorageBeforeTx {
    pub address: Address,  // â† åŒ…å«åœ°å€ï¼
    pub key: B256,         // â† å­˜å‚¨é”®
    pub value: U256,       // â† å­˜å‚¨å€¼
}

// ä½¿ç”¨åœºæ™¯ï¼šå†å²çŠ¶æ€ã€changesets
let storage_before = StorageBeforeTx {
    address: Address::from([0x12; 20]),
    key: B256::from([0x01; 32]),
    value: U256::from(100),
};
```

### åœºæ™¯ 4: RPC æŸ¥è¯¢ï¼ˆç»„åˆæ–¹å¼ï¼‰

```rust
// eth_getStorageAt RPC æ–¹æ³•

async fn storage_at(
    &self,
    address: Address,      // â† å‚æ•° 1ï¼šåˆçº¦åœ°å€
    index: JsonStorageKey, // â† å‚æ•° 2ï¼šæ§½ç´¢å¼•ï¼ˆU256 çš„ JSON è¡¨ç¤ºï¼‰
    block_id: BlockId,
) -> Result<U256> {       // â† è¿”å›å€¼
    let state = self.state_at_block_id(block_id)?;
    
    // æŸ¥è¯¢å­˜å‚¨
    let value = state.storage(address, index.as_b256())?;
    //                        â†‘        â†‘
    //                        åœ°å€     B256 æ ¼å¼çš„é”®
    
    Ok(value.unwrap_or_default())
}
```

---

## ğŸ¯ å…³é”®ç±»å‹å·®å¼‚ï¼šB256 vs U256

### ä¸ºä»€ä¹ˆ key ç”¨ B256 è€Œä¸æ˜¯ U256ï¼Ÿ

```rust
// B256ï¼š32 å­—èŠ‚æ•°ç»„ï¼ˆå“ˆå¸Œã€åœ°å€ã€ç´¢å¼•ï¼‰
pub struct B256([u8; 32]);

// U256ï¼š256 ä½æ— ç¬¦å·æ•´æ•°ï¼ˆå€¼ã€æ•°é‡ï¼‰
pub struct U256 {
    limbs: [u64; 4],
}
```

**é€‰æ‹© B256 ä½œä¸º key çš„åŸå› **ï¼š

```
1ï¸âƒ£ è¯­ä¹‰æ­£ç¡®
   â”œâ”€ Storage key æ˜¯ä¸€ä¸ª"ä½ç½®/ç´¢å¼•"ï¼Œä¸æ˜¯"æ•°é‡"
   â”œâ”€ æ›´æ¥è¿‘"åœ°å€"çš„æ¦‚å¿µï¼ˆ32 å­—èŠ‚æ ‡è¯†ç¬¦ï¼‰
   â””â”€ åœ¨ Merkle Patricia Trie ä¸­ç”¨ä½œè·¯å¾„

2ï¸âƒ£ æ€§èƒ½ä¼˜åŠ¿
   â”œâ”€ B256 æ˜¯ç®€å•çš„å­—èŠ‚æ•°ç»„ï¼Œå¤åˆ¶æ›´å¿«
   â”œâ”€ å“ˆå¸Œæ“ä½œç›´æ¥ä½œç”¨äºå­—èŠ‚
   â””â”€ æ•°æ®åº“é”®é€šå¸¸æ˜¯å­—èŠ‚åºåˆ—

3ï¸âƒ£ å…¼å®¹æ€§
   â”œâ”€ Keccak256 è¾“å‡ºæ˜¯ B256
   â”œâ”€ Trie èŠ‚ç‚¹é”®æ˜¯ B256
   â””â”€ ä¸ä»¥å¤ªåŠé»„çš®ä¹¦è§„èŒƒä¸€è‡´

ç¤ºä¾‹è½¬æ¢:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åœºæ™¯ 1: Solidity mapping            â”‚
â”‚ mapping(uint256 => uint256) data;   â”‚
â”‚                                     â”‚
â”‚ data[42] = 100;                     â”‚
â”‚   â†“                                 â”‚
â”‚ Slot Key = keccak256(42, base_slot)â”‚
â”‚          = 0xabcd...1234 (B256)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åœºæ™¯ 2: ç®€å•çŠ¶æ€å˜é‡                â”‚
â”‚ uint256 public count;  // slot 0    â”‚
â”‚                                     â”‚
â”‚ count = 100;                        â”‚
â”‚   â†“                                 â”‚
â”‚ Slot Key = 0x0000...0000 (B256)    â”‚
â”‚          = U256(0).to_be_bytes()   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ å®Œæ•´çš„å­˜å‚¨æ§½ç”Ÿå‘½å‘¨æœŸ

### 1. å†™å…¥å­˜å‚¨æ§½ï¼ˆSSTORE æŒ‡ä»¤ï¼‰

```rust
// Solidity åˆçº¦
contract Example {
    uint256 public value;  // slot 0
    
    function setValue(uint256 newValue) public {
        value = newValue;  // â† SSTORE æŒ‡ä»¤
    }
}

// EVM æ‰§è¡Œæµç¨‹
fn execute_sstore(
    evm: &mut Evm,
    address: Address,
    slot: U256,      // æ§½ç´¢å¼•ï¼ˆè¿™é‡Œæ˜¯ 0ï¼‰
    value: U256,     // æ–°å€¼
) -> Result<()> {
    // 1ï¸âƒ£ REVM è°ƒç”¨ Database::storage å†™å…¥
    let key = B256::new(slot.to_be_bytes());
    
    // 2ï¸âƒ£ è¿½è¸ªåˆ° BundleState
    evm.db.bundle_state
        .state
        .entry(address)
        .or_default()
        .storage
        .insert(slot, value);
    //      â†‘     â†‘
    //      U256  U256ï¼ˆåœ¨ BundleState ä¸­ï¼‰
    
    Ok(())
}

// 3ï¸âƒ£ æ‰§è¡Œå®Œæˆåï¼ŒæŒä¹…åŒ–åˆ°æ•°æ®åº“
fn finalize_block(bundle: BundleState) -> Result<()> {
    for (address, account) in bundle.state {
        for (slot, value) in account.storage {
            // è½¬æ¢ä¸º B256
            let key = B256::from(slot.to_be_bytes());
            
            // å­˜å‚¨åˆ°æ•°æ®åº“
            tx.put::<tables::PlainStorageState>(
                address,
                StorageEntry { key, value }
            )?;
        }
    }
    Ok(())
}
```

### 2. è¯»å–å­˜å‚¨æ§½ï¼ˆSLOAD æŒ‡ä»¤ï¼‰

```rust
// EVM æ‰§è¡Œ SLOAD
fn execute_sload(
    evm: &mut Evm,
    address: Address,
    slot: U256,
) -> Result<U256> {
    // 1ï¸âƒ£ REVM è°ƒç”¨ Database::storage
    let value = evm.db.storage(address, slot)?;
    //                         â†‘        â†‘
    //                         Address  U256
    
    // 2ï¸âƒ£ Database å†…éƒ¨è½¬æ¢
    // StateProviderDatabase::storage() {
    //     let key = B256::new(slot.to_be_bytes());  // U256 â†’ B256
    //     let entry = self.0.storage(address, key)?;
    //     Ok(entry.value)  // è¿”å› U256
    // }
    
    Ok(value)
}
```

### 3. å®Œæ•´æ•°æ®æµ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Solidity å±‚                                          â”‚
â”‚ mapping(uint256 => uint256) balances;                â”‚
â”‚ balances[user] = 100;                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ ç¼–è¯‘ä¸º EVM å­—èŠ‚ç 
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ EVM å±‚                                               â”‚
â”‚ SSTORE(slot=keccak256(user, 0), value=100)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ REVM æ‰§è¡Œ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ REVM å±‚ï¼ˆä¸‰å…ƒç»„ï¼‰                                    â”‚
â”‚ db.storage(                                          â”‚
â”‚     address: Address,   // åˆçº¦åœ°å€                 â”‚
â”‚     slot: U256,         // æ§½ç´¢å¼•                   â”‚
â”‚     value: U256         // å€¼                       â”‚
â”‚ )                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ è¿½è¸ªçŠ¶æ€å˜æ›´
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BundleState å±‚ï¼ˆå†…å­˜è¿½è¸ªï¼‰                           â”‚
â”‚ HashMap<Address, HashMap<U256, U256>>                â”‚
â”‚   address â†’ { slot â†’ value }                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ æŒä¹…åŒ–
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ•°æ®åº“å±‚ï¼ˆåˆ†ç¦»å­˜å‚¨ï¼‰                                 â”‚
â”‚ PlainStorageState {                                  â”‚
â”‚     Key: Address,       // ä¸»é”®                     â”‚
â”‚     SubKey: B256,       // å­˜å‚¨é”®ï¼ˆU256 â†’ B256ï¼‰    â”‚
â”‚     Value: StorageEntry { key: B256, value: U256 }  â”‚
â”‚ }                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’¡ å®é™…ä½¿ç”¨ç¤ºä¾‹

### ç¤ºä¾‹ 1: æŒ‰ä½ çš„ç†è§£ä½¿ç”¨ï¼ˆæ¦‚å¿µå±‚ï¼‰

```rust
// æ¦‚å¿µä¸Šï¼Œä½ å¯ä»¥è¿™æ ·æ€è€ƒï¼š
struct StorageSlot {
    address: Address,  // 0x1234... (åˆçº¦åœ°å€)
    key: U256,         // 0 (æ§½ç´¢å¼•)
    value: U256,       // 42 (å­˜å‚¨çš„å€¼)
}

// ç­‰ä»·äºï¼š
// "åœ¨åˆçº¦ 0x1234... çš„ç¬¬ 0 ä¸ªå­˜å‚¨æ§½ä¸­ï¼Œå€¼æ˜¯ 42"
```

### ç¤ºä¾‹ 2: Reth å®é™…ä»£ç ï¼ˆå®ç°å±‚ï¼‰

```rust
use reth_primitives_traits::StorageEntry;

// æŸ¥è¯¢å­˜å‚¨ï¼ˆåˆ†ç¦»æ–¹å¼ï¼‰
async fn get_storage(
    provider: &Provider,
    address: Address,
    slot: U256,
) -> Result<U256> {
    // è½¬æ¢ U256 â†’ B256
    let key = B256::from(slot.to_be_bytes());
    
    // æŸ¥è¯¢æ•°æ®åº“ï¼ˆaddress å’Œ key åˆ†ç¦»ï¼‰
    let entry: Option<StorageEntry> = provider
        .tx()
        .cursor_dup_read::<tables::PlainStorageState>()?
        .seek_by_key_subkey(address, key)?;
    
    // æå– value
    Ok(entry.map(|e| e.value).unwrap_or_default())
}

// å†™å…¥å­˜å‚¨
async fn set_storage(
    provider: &Provider,
    address: Address,
    slot: U256,
    value: U256,
) -> Result<()> {
    let key = B256::from(slot.to_be_bytes());
    
    let storage_entry = StorageEntry { key, value };
    
    provider
        .tx_mut()
        .put::<tables::PlainStorageState>(address, storage_entry)?;
    
    Ok(())
}
```

### ç¤ºä¾‹ 3: åŒ…å« address çš„åœºæ™¯

```rust
// åœºæ™¯ï¼šè¿½è¸ªçŠ¶æ€å˜æ›´å†å²
use reth_db_models::StorageBeforeTx;

fn record_storage_change(
    address: Address,
    slot: B256,
    old_value: U256,
    new_value: U256,
    block_number: u64,
) -> Result<()> {
    // è®°å½•å˜æ›´å‰çš„å€¼ï¼ˆåŒ…å« addressï¼‰
    let storage_before = StorageBeforeTx {
        address,
        key: slot,
        value: old_value,
    };
    
    // å†™å…¥ StorageChangeSets è¡¨
    tx.put::<tables::StorageChangeSets>(
        BlockNumberAddress((block_number, address)),
        StorageEntry { key: slot, value: old_value }
    )?;
    
    Ok(())
}
```

---

## ğŸ¨ Solidity å­˜å‚¨å¸ƒå±€ç¤ºä¾‹

### ç®€å•çŠ¶æ€å˜é‡

```solidity
contract Example {
    uint256 public a;      // slot 0
    uint256 public b;      // slot 1
    address public owner;  // slot 2
}

// å­˜å‚¨æ˜ å°„:
// Address: 0xContract...
//   â”œâ”€ Slot 0x00...00 â†’ a çš„å€¼
//   â”œâ”€ Slot 0x00...01 â†’ b çš„å€¼
//   â””â”€ Slot 0x00...02 â†’ owner çš„å€¼ï¼ˆå·¦ä¾§å¡«å…… 0ï¼‰
```

### Mapping å­˜å‚¨å¸ƒå±€

```solidity
contract Example {
    mapping(address => uint256) public balances;  // slot 0
    
    // balances[user] çš„å­˜å‚¨ä½ç½®ï¼š
    // slot = keccak256(abi.encode(user, 0))
}

// å­˜å‚¨æ˜ å°„:
// Address: 0xContract...
//   â”œâ”€ Slot keccak256(user1, 0) â†’ user1 çš„ä½™é¢
//   â”œâ”€ Slot keccak256(user2, 0) â†’ user2 çš„ä½™é¢
//   â””â”€ Slot keccak256(user3, 0) â†’ user3 çš„ä½™é¢
```

### åŠ¨æ€æ•°ç»„

```solidity
contract Example {
    uint256[] public items;  // slot 0
    
    // items.length å­˜å‚¨åœ¨ slot 0
    // items[i] å­˜å‚¨åœ¨ keccak256(0) + i
}

// å­˜å‚¨æ˜ å°„:
// Address: 0xContract...
//   â”œâ”€ Slot 0x00...00 â†’ æ•°ç»„é•¿åº¦
//   â”œâ”€ Slot keccak256(0) + 0 â†’ items[0]
//   â”œâ”€ Slot keccak256(0) + 1 â†’ items[1]
//   â””â”€ Slot keccak256(0) + 2 â†’ items[2]
```

---

## ğŸ” è°ƒè¯•å’Œæ£€æŸ¥å­˜å‚¨æ§½

### æ–¹æ³• 1: ä½¿ç”¨ castï¼ˆFoundryï¼‰

```bash
# è¯»å–å­˜å‚¨æ§½
cast storage 0xContractAddress 0x0  # è¯»å– slot 0

# è¯»å– mapping çš„å€¼
# balances[user] = balances[keccak256(user, 0)]
cast storage 0xContractAddress $(cast index address 0xUserAddress 0)
```

### æ–¹æ³• 2: ä½¿ç”¨ eth_getStorageAt RPC

```bash
curl -X POST http://localhost:8545 \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "eth_getStorageAt",
    "params": [
      "0xContractAddress",  // åˆçº¦åœ°å€
      "0x0",                // æ§½ç´¢å¼•
      "latest"              // åŒºå—
    ],
    "id": 1
  }'
```

### æ–¹æ³• 3: åœ¨ Reth ä¸­ç›´æ¥æŸ¥è¯¢

```rust
use reth_provider::ProviderFactory;

#[tokio::main]
async fn main() -> Result<()> {
    let factory = ProviderFactory::new(...);
    let provider = factory.latest()?;
    
    let address = Address::from_str("0x...")?;
    let slot = U256::from(0);  // slot 0
    
    // æŸ¥è¯¢å­˜å‚¨
    let key = B256::from(slot.to_be_bytes());
    let value = provider.storage(address, key)?;
    
    println!("Storage at slot 0: {:?}", value);
    
    Ok(())
}
```

---

## ğŸ“Š å­˜å‚¨æ§½çš„æ€§èƒ½è€ƒè™‘

### 1. å­˜å‚¨æˆæœ¬ï¼ˆGasï¼‰

```
æ“ä½œ                    | Gas æˆæœ¬
-----------------------|----------
SSTORE (0 â†’ é0)       | 20,000
SSTORE (é0 â†’ é0)     | 5,000
SSTORE (é0 â†’ 0)       | 5,000 (é€€æ¬¾ 15,000)
SLOAD                  | 100 (å†·è®¿é—® 2,100)
```

### 2. å­˜å‚¨ä¼˜åŒ–å»ºè®®

```solidity
// âŒ ä¸å¥½ï¼šæ¯ä¸ªå˜é‡å ç”¨ä¸€ä¸ªå®Œæ•´çš„æ§½
contract Bad {
    uint8 a;   // slot 0 (æµªè´¹ 31 å­—èŠ‚)
    uint8 b;   // slot 1 (æµªè´¹ 31 å­—èŠ‚)
    uint8 c;   // slot 2 (æµªè´¹ 31 å­—èŠ‚)
}

// âœ… å¥½ï¼šæ‰“åŒ…åˆ°åŒä¸€ä¸ªæ§½
contract Good {
    uint8 a;   // slot 0 [0:1]
    uint8 b;   // slot 0 [1:2]
    uint8 c;   // slot 0 [2:3]
    // å¯ä»¥èŠ‚çœ 2 ä¸ª SSTORE æ“ä½œï¼
}
```

### 3. Reth çš„å­˜å‚¨ä¼˜åŒ–

```
ä¼˜åŒ– 1: DupSort è¡¨
â”œâ”€ æŒ‰åœ°å€åˆ†ç»„å­˜å‚¨
â”œâ”€ å‡å°‘ç´¢å¼•å¤§å°
â””â”€ æé«˜ç¼“å­˜å±€éƒ¨æ€§

ä¼˜åŒ– 2: é™æ€æ–‡ä»¶å­˜å‚¨
â”œâ”€ å†å²çŠ¶æ€å­˜å‚¨åœ¨é™æ€æ–‡ä»¶
â”œâ”€ å‡å°‘æ•°æ®åº“å¤§å°
â””â”€ æé«˜æŸ¥è¯¢é€Ÿåº¦

ä¼˜åŒ– 3: ç¨€ç– Trie
â”œâ”€ åªè®¡ç®—å˜æ›´çš„éƒ¨åˆ†
â”œâ”€ å¢é‡ State Root
â””â”€ å¹¶è¡Œè®¡ç®—
```

---

## ğŸ“ æ€»ç»“

### ä½ çš„ç†è§£ vs Reth å®ç°

```
ä½ çš„æ¦‚å¿µæ¨¡å‹ï¼ˆæ­£ç¡®ï¼ï¼‰:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ StorageSlot {                  â”‚
â”‚     address: Address,          â”‚
â”‚     key: U256,                 â”‚
â”‚     value: U256,               â”‚
â”‚ }                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Reth å®é™…å®ç°ï¼ˆæ ¹æ®åœºæ™¯ä¸åŒï¼‰:

åœºæ™¯ 1: æ•°æ®åº“å­˜å‚¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PlainStorageState è¡¨:          â”‚
â”‚   Key: Address                 â”‚
â”‚   SubKey: B256                 â”‚
â”‚   Value: StorageEntry {        â”‚
â”‚       key: B256,               â”‚
â”‚       value: U256              â”‚
â”‚   }                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

åœºæ™¯ 2: REVM æ‰§è¡Œ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ db.storage(                    â”‚
â”‚     address: Address,          â”‚
â”‚     slot: U256                 â”‚
â”‚ ) -> U256                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

åœºæ™¯ 3: å†å²è¿½è¸ª
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ StorageBeforeTx {              â”‚
â”‚     address: Address,          â”‚
â”‚     key: B256,                 â”‚
â”‚     value: U256,               â”‚
â”‚ }                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å…³é”®è¦ç‚¹

```
âœ… æ¦‚å¿µä¸Šï¼šä¸‰å…ƒç»„ (address, key, value) æ˜¯æ­£ç¡®çš„
âœ… key çš„ç±»å‹ï¼šB256ï¼ˆå­—èŠ‚æ•°ç»„ï¼‰æ¯” U256ï¼ˆæ•´æ•°ï¼‰æ›´åˆé€‚
âœ… æ•°æ®åº“è®¾è®¡ï¼šaddress é€šå¸¸ä½œä¸ºä¸»é”®åˆ†ç¦»å­˜å‚¨ï¼ˆç©ºé—´å’Œæ€§èƒ½ä¼˜åŒ–ï¼‰
âœ… REVM æ¥å£ï¼šä½¿ç”¨ U256 ä½œä¸º slotï¼ˆæ›´æ¥è¿‘ EVM è§„èŒƒï¼‰
âœ… ç±»å‹è½¬æ¢ï¼šU256 â†” B256 è½¬æ¢å¾ˆå¸¸è§ä¸”å¿…è¦
```

### æœ€ä½³å®è·µ

```
1ï¸âƒ£ ç†è§£æ—¶ï¼šç”¨ä½ çš„ä¸‰å…ƒç»„æ¨¡å‹æ€è€ƒ
2ï¸âƒ£ å®ç°æ—¶ï¼šæ ¹æ®åœºæ™¯é€‰æ‹©åˆé€‚çš„ç»“æ„
   â”œâ”€ æ•°æ®åº“ï¼šåˆ†ç¦» address
   â”œâ”€ REVMï¼šä¸‰å…ƒç»„æ¥å£
   â””â”€ å†å²ï¼šå®Œæ•´ä¸‰å…ƒç»„
3ï¸âƒ£ ç±»å‹é€‰æ‹©ï¼š
   â”œâ”€ key ç”¨ B256ï¼ˆæ ‡è¯†ç¬¦è¯­ä¹‰ï¼‰
   â””â”€ value ç”¨ U256ï¼ˆæ•°å€¼è¯­ä¹‰ï¼‰
```

---

## ğŸ”— ç›¸å…³ä»£ç ä½ç½®

```
æ ¸å¿ƒå®šä¹‰:
â”œâ”€ crates/primitives-traits/src/storage.rs:22     (StorageEntry)
â”œâ”€ crates/storage/db-models/src/storage.rs:11     (StorageBeforeTx)
â””â”€ crates/storage/db-api/src/tables/mod.rs:393    (PlainStorageState è¡¨)

REVM æ¥å£:
â”œâ”€ crates/revm/src/database.rs:126                (Database::storage)
â””â”€ crates/revm/src/database.rs:160                (DatabaseRef::storage_ref)

ä½¿ç”¨ç¤ºä¾‹:
â”œâ”€ crates/ethereum/evm/tests/execute.rs:127       (è¯»å–å­˜å‚¨)
â”œâ”€ crates/storage/provider/src/writer/mod.rs:224  (å†™å…¥å­˜å‚¨)
â””â”€ examples/db-access/src/main.rs:226             (æŸ¥è¯¢ç¤ºä¾‹)
```

---

---

## âš ï¸ é‡è¦é™åˆ¶ï¼š256 ä½å­˜å‚¨æ§½

### æ˜¯çš„ï¼æ¯ä¸ªå­˜å‚¨æ§½çš„ value æ°¸è¿œä¸ä¼šè¶…è¿‡ 256 ä½

```
EVM å­˜å‚¨æ§½çš„é“å¾‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ¯ä¸ªå­˜å‚¨æ§½ = æ°å¥½ 256 ä½ (32 å­—èŠ‚) â”‚
â”‚                                    â”‚
â”‚ è¿™æ˜¯ EVM æ¶æ„çš„åŸºæœ¬çº¦æŸï¼          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

åŸå› :
1ï¸âƒ£ EVM å­—é•¿ (word size) = 256 ä½
2ï¸âƒ£ æ‰€æœ‰ EVM æŒ‡ä»¤æ“ä½œ 256 ä½å€¼
3ï¸âƒ£ Stack å’Œ Memory ä¹Ÿæ˜¯ 256 ä½å¯¹é½
4ï¸âƒ£ é»„çš®ä¹¦è§„èŒƒæ˜ç¡®å®šä¹‰
```

### ç±»å‹å¤§å°å¯¹ç…§è¡¨

```
Rust/Reth ç±»å‹     | ä½æ•°  | å­—èŠ‚æ•° | è¯´æ˜
-------------------|-------|--------|------------------
U256               | 256   | 32     | æ°å¥½ä¸€ä¸ªæ§½
B256               | 256   | 32     | æ°å¥½ä¸€ä¸ªæ§½
Address            | 160   | 20     | å°äºä¸€ä¸ªæ§½ï¼ˆå³å¡«å…… 0ï¼‰
u64                | 64    | 8      | è¿œå°äºä¸€ä¸ªæ§½
u128               | 128   | 16     | åŠä¸ªæ§½
bool               | 8     | 1      | æå°ï¼ˆä½†å ç”¨å®Œæ•´æ§½ï¼‰
```

### å­˜å‚¨æ§½çš„"é‡å­åŒ–"ç‰¹æ€§

```rust
// âŒ ä¸å­˜åœ¨"åŠä¸ªæ§½"æˆ–"1.5 ä¸ªæ§½"
// âœ… åªèƒ½ä»¥æ•´æ§½ä¸ºå•ä½å­˜å‚¨

// Solidity ç¤ºä¾‹
contract Example {
    uint256 a;  // å ç”¨ 1 ä¸ªå®Œæ•´æ§½ï¼ˆslot 0ï¼‰
    uint128 b;  // å ç”¨ 1 ä¸ªå®Œæ•´æ§½ï¼ˆslot 1ï¼‰- æµªè´¹äº† 128 ä½ï¼
    uint64 c;   // å ç”¨ 1 ä¸ªå®Œæ•´æ§½ï¼ˆslot 2ï¼‰- æµªè´¹äº† 192 ä½ï¼
    bool d;     // å ç”¨ 1 ä¸ªå®Œæ•´æ§½ï¼ˆslot 3ï¼‰- æµªè´¹äº† 248 ä½ï¼
}

// æ•°æ®åº“ä¸­çš„å®é™…å­˜å‚¨:
// Slot 0: 0x0000...a_value (32 bytes)
// Slot 1: 0x0000...b_value (32 bytes, å‰ 16 å­—èŠ‚æ˜¯ 0)
// Slot 2: 0x0000...c_value (32 bytes, å‰ 24 å­—èŠ‚æ˜¯ 0)
// Slot 3: 0x0000...d_value (32 bytes, å‰ 31 å­—èŠ‚æ˜¯ 0)
```

---

## ğŸ”§ å¦‚ä½•å­˜å‚¨è¶…è¿‡ 256 ä½çš„æ•°æ®ï¼Ÿ

### ç­–ç•¥ 1: ä½¿ç”¨å¤šä¸ªæ§½ï¼ˆæ•°ç»„ï¼‰

```solidity
contract LargeData {
    // å­˜å‚¨ 512 ä½çš„æ•°æ® = 2 ä¸ªæ§½
    uint256[2] public data512;
    
    function setLargeData(uint256 part1, uint256 part2) public {
        data512[0] = part1;  // slot: keccak256(slot_base) + 0
        data512[1] = part2;  // slot: keccak256(slot_base) + 1
    }
}

// åœ¨é“¾ä¸Šå­˜å‚¨:
// Slot keccak256(0) + 0: part1 (256 bits)
// Slot keccak256(0) + 1: part2 (256 bits)
// æ€»å…±: 512 bits
```

### ç­–ç•¥ 2: ç»“æ„ä½“ï¼ˆå¤šä¸ªæ§½ï¼‰

```solidity
contract User {
    struct Profile {
        address addr;      // 160 bits
        uint256 balance;   // 256 bits
        uint256 score;     // 256 bits
        bytes32 name;      // 256 bits
    }
    
    Profile public user;
    
    // å­˜å‚¨å¸ƒå±€ï¼ˆä¼˜åŒ–å‰ï¼‰:
    // Slot 0: addr (160 bits, æµªè´¹ 96 bits)
    // Slot 1: balance (256 bits)
    // Slot 2: score (256 bits)
    // Slot 3: name (256 bits)
    // æ€»å…±: 4 ä¸ªæ§½ = 1024 bits
}
```

### ç­–ç•¥ 3: æ§½æ‰“åŒ…ï¼ˆSlot Packingï¼‰

```solidity
contract Optimized {
    // âœ… ä¼˜åŒ–ï¼šå¤šä¸ªå°å˜é‡æ‰“åŒ…åˆ°åŒä¸€æ§½
    uint128 public a;  // slot 0 [0:16]
    uint128 public b;  // slot 0 [16:32] - åŒä¸€ä¸ªæ§½ï¼
    
    uint64 public c;   // slot 1 [0:8]
    uint64 public d;   // slot 1 [8:16]
    uint64 public e;   // slot 1 [16:24]
    uint64 public f;   // slot 1 [24:32] - 4 ä¸ªå˜é‡å…±äº«ä¸€ä¸ªæ§½ï¼
    
    // å­˜å‚¨æ•ˆç‡ï¼š
    // åŸæœ¬éœ€è¦ 6 ä¸ªæ§½ï¼Œç°åœ¨åªéœ€è¦ 2 ä¸ªæ§½
    // èŠ‚çœ: (6 - 2) * 20,000 gas = 80,000 gas!
}
```

### ç­–ç•¥ 4: å­—èŠ‚æ•°ç»„/å­—ç¬¦ä¸²ï¼ˆåŠ¨æ€é•¿åº¦ï¼‰

```solidity
contract DynamicData {
    bytes public data;  // å¯ä»¥è¶…è¿‡ 256 ä½ï¼
    
    function setData(bytes memory newData) public {
        data = newData;
        // å¦‚æœ newData.length > 32:
        // - Slot 0: å­˜å‚¨é•¿åº¦ä¿¡æ¯
        // - Slot keccak256(0) + 0: å‰ 32 å­—èŠ‚
        // - Slot keccak256(0) + 1: æ¥ä¸‹æ¥ 32 å­—èŠ‚
        // - ... ä¾æ­¤ç±»æ¨
    }
}

// ç¤ºä¾‹ï¼šå­˜å‚¨ 100 å­—èŠ‚çš„æ•°æ®
// Slot 0: 0x...0064 (é•¿åº¦ = 100)
// Slot keccak256(0) + 0: bytes[0:32]
// Slot keccak256(0) + 1: bytes[32:64]
// Slot keccak256(0) + 2: bytes[64:96]
// Slot keccak256(0) + 3: bytes[96:100] (æœ€å 4 å­—èŠ‚ + å¡«å……)
// æ€»å…±: 5 ä¸ªæ§½
```

---

## ğŸ“Š å­˜å‚¨æ§½çš„å®é™…å¤§å°ç¤ºä¾‹

### åœ¨ Reth ä»£ç ä¸­éªŒè¯

```rust
use alloy_primitives::U256;
use std::mem::size_of;

fn main() {
    // U256 çš„å®é™…å¤§å°
    println!("U256 size: {} bytes", size_of::<U256>());
    // è¾“å‡º: U256 size: 32 bytes (= 256 bits)
    
    // U256 çš„ä½æ•°
    println!("U256 bits: {}", U256::BITS);
    // è¾“å‡º: U256 bits: 256
    
    // U256 çš„æœ€å¤§å€¼
    println!("U256::MAX: {}", U256::MAX);
    // è¾“å‡º: U256::MAX: 115792089237316195423570985008687907853269984665640564039457584007913129639935
    // (å³ 2^256 - 1)
    
    // éªŒè¯ï¼šæ— æ³•å­˜å‚¨è¶…è¿‡ 256 ä½çš„å€¼
    let max_value = U256::MAX;
    // max_value + 1 ä¼šæº¢å‡ºï¼Œå›ç»•åˆ° 0
    let overflow = max_value.overflowing_add(U256::from(1));
    println!("MAX + 1 = {:?}", overflow);
    // è¾“å‡º: (U256([0, 0, 0, 0]), true)  // æº¢å‡ºï¼
}
```

### å®é™…æ•°æ®åº“å­˜å‚¨éªŒè¯

```rust
use reth_primitives_traits::StorageEntry;

// åˆ›å»ºä¸€ä¸ªå­˜å‚¨æ¡ç›®
let entry = StorageEntry {
    key: B256::from([0x01; 32]),      // 32 å­—èŠ‚çš„é”®
    value: U256::from(u128::MAX),     // å€¼ä¸èƒ½è¶…è¿‡ U256::MAX
};

// å°è¯•å­˜å‚¨æ›´å¤§çš„å€¼ï¼Ÿä¸å¯èƒ½ï¼
// U256 ç±»å‹æœ¬èº«å°±é™åˆ¶äº†æœ€å¤§å€¼ä¸º 2^256 - 1

// ç¼–è¯‘æ—¶é”™è¯¯ç¤ºä¾‹ï¼š
// let too_large: U256 = 2_u256.pow(256);  // âŒ ç¼–è¯‘é”™è¯¯ï¼æ— æ³•è¡¨ç¤º
```

---

## ğŸ¨ å®é™… Gas æˆæœ¬å½±å“

### å•æ§½ vs å¤šæ§½çš„æˆæœ¬

```solidity
contract GasCost {
    // åœºæ™¯ 1: å­˜å‚¨ 256 ä½æ•°æ®ï¼ˆ1 ä¸ªæ§½ï¼‰
    uint256 public data256;
    
    function set256(uint256 value) public {
        data256 = value;  // æˆæœ¬: 20,000 gas (é¦–æ¬¡å†™å…¥)
    }
    
    // åœºæ™¯ 2: å­˜å‚¨ 512 ä½æ•°æ®ï¼ˆ2 ä¸ªæ§½ï¼‰
    uint256[2] public data512;
    
    function set512(uint256[2] memory values) public {
        data512[0] = values[0];  // æˆæœ¬: 20,000 gas
        data512[1] = values[1];  // æˆæœ¬: 20,000 gas
        // æ€»æˆæœ¬: 40,000 gas (2 å€)
    }
    
    // åœºæ™¯ 3: æ§½æ‰“åŒ…ï¼ˆ2 ä¸ª uint128 åœ¨ 1 ä¸ªæ§½ä¸­ï¼‰
    uint128 public a;
    uint128 public b;
    
    function setPacked(uint128 _a, uint128 _b) public {
        a = _a;  // æˆæœ¬: 20,000 gas (é¦–æ¬¡)
        b = _b;  // æˆæœ¬: 5,000 gas (åŒä¸€æ§½çš„ä¿®æ”¹)
        // æ€»æˆæœ¬: 25,000 gas (æ¯” 40,000 ä¾¿å®œå¾ˆå¤šï¼)
    }
}
```

---

## ğŸ” ç‰¹æ®Šæƒ…å†µï¼šåŠ¨æ€ç±»å‹çš„å­˜å‚¨

### bytes å’Œ string çš„å¤šæ§½å­˜å‚¨

```solidity
contract DynamicStorage {
    string public name;  // å¯ä»¥æ˜¯ä»»æ„é•¿åº¦ï¼
    
    function setShortName(string memory _name) public {
        // å¦‚æœ length <= 31:
        // - æ•°æ®å’Œé•¿åº¦éƒ½å­˜å‚¨åœ¨åŒä¸€ä¸ªæ§½ä¸­
        // - æ ¼å¼: [data...][length*2]
        name = "Alice";  // 5 å­—èŠ‚ï¼Œå•æ§½å­˜å‚¨
    }
    
    function setLongName(string memory _name) public {
        // å¦‚æœ length >= 32:
        // - Slot 0: å­˜å‚¨ (length * 2 + 1)
        // - Slot keccak256(0) + i: å­˜å‚¨å®é™…æ•°æ®
        name = "A very long name that exceeds 32 bytes...";
        // å¤šæ§½å­˜å‚¨ï¼
    }
}
```

### mapping çš„è™šæ‹Ÿæ— é™å­˜å‚¨

```solidity
contract MappingStorage {
    // mapping ç†è®ºä¸Šå¯ä»¥æœ‰ 2^256 ä¸ªæ¡ç›®ï¼
    mapping(uint256 => uint256) public data;
    
    function set(uint256 key, uint256 value) public {
        // æ¯ä¸ªé”®å€¼å¯¹å ç”¨ 1 ä¸ªæ§½
        // æ§½ä½ç½® = keccak256(abi.encode(key, slot))
        data[key] = value;
        
        // å³ä½¿ key æ˜¯ U256::MAXï¼Œä¹Ÿåªæ˜¯ä¸€ä¸ªä¸åŒçš„æ§½
        // ä¸å­˜åœ¨"è¶…è¿‡ 256 ä½"çš„é—®é¢˜
    }
}
```

---

## ğŸ’¡ å…³é”®è¦ç‚¹æ€»ç»“

### å­˜å‚¨æ§½çš„ç¡¬æ€§çº¦æŸ

```
âœ… æ¯ä¸ªæ§½ = æ°å¥½ 256 ä½ (32 å­—èŠ‚)
âœ… Value ç±»å‹ = U256 (ä¸èƒ½è¶…è¿‡ 2^256 - 1)
âœ… Key ç±»å‹ = B256 (æ ‡è¯†ç¬¦ï¼Œä¹Ÿæ˜¯ 256 ä½)
âœ… è¿™æ˜¯ EVM æ¶æ„çš„åŸºæœ¬é™åˆ¶
```

### å­˜å‚¨è¶…è¿‡ 256 ä½çš„æ–¹æ³•

```
æ–¹æ³• 1: ä½¿ç”¨å¤šä¸ªæ§½ï¼ˆæ•°ç»„/ç»“æ„ä½“ï¼‰
  â”œâ”€ 512 bits = 2 ä¸ªæ§½
  â”œâ”€ 1024 bits = 4 ä¸ªæ§½
  â””â”€ ä¾æ­¤ç±»æ¨

æ–¹æ³• 2: åŠ¨æ€æ•°æ®ç±»å‹ï¼ˆbytes/stringï¼‰
  â”œâ”€ è‡ªåŠ¨è·¨æ§½å­˜å‚¨
  â”œâ”€ é•¿åº¦ä¿¡æ¯å•ç‹¬å­˜å‚¨
  â””â”€ é€‚åˆä»»æ„é•¿åº¦æ•°æ®

æ–¹æ³• 3: mappingï¼ˆè™šæ‹Ÿæ— é™ï¼‰
  â”œâ”€ æ¯ä¸ªæ¡ç›®ä¸€ä¸ªæ§½
  â”œâ”€ ä½ç½®ç”±å“ˆå¸Œè®¡ç®—
  â””â”€ ç†è®ºä¸Š 2^256 ä¸ªæ¡ç›®
```

### Gas ä¼˜åŒ–æŠ€å·§

```
1ï¸âƒ£ æ§½æ‰“åŒ…
  â””â”€ å¤šä¸ªå°å˜é‡å…±äº«ä¸€ä¸ªæ§½

2ï¸âƒ£ é¿å…æµªè´¹
  â””â”€ uint8 å•ç‹¬å­˜å‚¨æµªè´¹ 248 ä½

3ï¸âƒ£ å†·çƒ­åˆ†ç¦»
  â””â”€ å¸¸è®¿é—®çš„å˜é‡æ‰“åŒ…åœ¨ä¸€èµ·

4ï¸âƒ£ ä½¿ç”¨ immutable/constant
  â””â”€ ä¸å ç”¨å­˜å‚¨æ§½ï¼ˆç¼–è¯‘æ—¶å†…è”ï¼‰
```

### åœ¨ Reth ä¸­çš„ä½“ç°

```rust
// æ‰€æœ‰å­˜å‚¨ç›¸å…³çš„ç±»å‹éƒ½æ˜¯ U256
use alloy_primitives::U256;

// ä¸å¯èƒ½å®šä¹‰è¶…è¿‡ 256 ä½çš„å­˜å‚¨å€¼
pub struct StorageEntry {
    pub key: B256,    // 256 ä½
    pub value: U256,  // 256 ä½ â† ç¡¬é™åˆ¶ï¼
}

// å¦‚æœéœ€è¦æ›´å¤§çš„å€¼ï¼Œåº”ç”¨å±‚é€»è¾‘å¿…é¡»ï¼š
// 1. æ‹†åˆ†æˆå¤šä¸ª U256
// 2. å­˜å‚¨åœ¨å¤šä¸ªæ§½ä¸­
// 3. è¯»å–æ—¶é‡æ–°ç»„åˆ
```

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

### é»„çš®ä¹¦è§„èŒƒ

```
ä»¥å¤ªåŠé»„çš®ä¹¦æ˜ç¡®å®šä¹‰:
â”œâ”€ Ïƒ[a]_s: è´¦æˆ·å­˜å‚¨ï¼ˆstorageï¼‰
â”œâ”€ Ïƒ[a]_s[k]: å­˜å‚¨æ§½ k çš„å€¼
â”œâ”€ ç±»å‹: k âˆˆ Bâ‚‚â‚…â‚†, v âˆˆ Bâ‚‚â‚…â‚†
â””â”€ å«ä¹‰: é”®å’Œå€¼éƒ½æ˜¯ 256 ä½å­—èŠ‚åºåˆ—
```

### EVM æŒ‡ä»¤é›†

```
SSTORE (0x55):
â”œâ”€ ä»æ ˆå¼¹å‡º 2 ä¸ª 256 ä½å€¼
â”œâ”€ key (ä½ç½®) å’Œ value (å€¼)
â””â”€ å­˜å‚¨åˆ°å½“å‰åˆçº¦çš„å­˜å‚¨ä¸­

SLOAD (0x54):
â”œâ”€ ä»æ ˆå¼¹å‡º 1 ä¸ª 256 ä½å€¼ (key)
â”œâ”€ ä»å­˜å‚¨è¯»å–å¯¹åº”çš„ value
â””â”€ å‹å…¥æ ˆï¼ˆ256 ä½å€¼ï¼‰
```

---

## âš ï¸ é‡è¦å‘ç°ï¼škey è¢«å­˜å‚¨äº†ä¸¤æ¬¡ï¼

### å†—ä½™å­˜å‚¨çš„çœŸç›¸

ä½ å¯èƒ½æ³¨æ„åˆ°äº†ä¸€ä¸ªå¥‡æ€ªçš„ç°è±¡ï¼šåœ¨ `PlainStorageState` è¡¨ä¸­ï¼Œ`B256` çš„ key ä¼¼ä¹è¢«å­˜å‚¨äº†**ä¸¤æ¬¡**ï¼

```rust
table PlainStorageState {
    type Key = Address,
    type SubKey = B256,        // â† ç¬¬ä¸€æ¬¡ï¼šä½œä¸ºç´¢å¼•
    type Value = StorageEntry { 
        key: B256,             // â† ç¬¬äºŒæ¬¡ï¼šä½œä¸ºæ•°æ®ï¼
        value: U256 
    }
}
```

**è¿™ä¸æ˜¯æ–‡æ¡£é”™è¯¯ï¼Œè€Œæ˜¯çœŸå®çš„è®¾è®¡å†³ç­–ï¼**

### ç‰©ç†å­˜å‚¨å¸ƒå±€

```
MDBX DupSort è¡¨çš„å®é™…ç‰©ç†å­˜å‚¨ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Key: Address = 0x1234...                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€ SubKey: B256 = 0xABCD... â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚  â† ç¬¬ä¸€æ¬¡å­˜å‚¨
â”‚ â”‚  (ç”¨äº MDBX å†…éƒ¨ç´¢å¼•å’Œæ’åº)         â”‚         â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                â”‚
â”‚ â”Œâ”€ Value: StorageEntry                        â”‚
â”‚ â”‚   â”Œâ”€ key: B256 = 0xABCD... â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚  â† ç¬¬äºŒæ¬¡å­˜å‚¨ï¼ˆç›¸åŒå€¼ï¼ï¼‰
â”‚ â”‚   â”‚  (32 bytes, æœªå‹ç¼©)                     â”‚
â”‚ â”‚   â”‚                                         â”‚
â”‚ â”‚   â””â”€ value: U256 = 42 (å‹ç¼©å)             â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å†—ä½™ï¼ä½†æœ‰å……åˆ†ç†ç”±ï¼
```

### ä¸ºä»€ä¹ˆè¦è¿™æ ·è®¾è®¡ï¼Ÿ

æŸ¥çœ‹ `StorageEntry` çš„ç¼–ç å®ç°ï¼ˆ`crates/primitives-traits/src/storage.rs:50-68`ï¼‰ï¼š

```rust
// NOTE: Removing reth_codec and manually encode subkey
// and compress second part of the value. If we have compression
// over whole value (Even SubKey) that would mess up fetching of 
// values with seek_by_key_subkey
impl reth_codecs::Compact for StorageEntry {
    fn to_compact<B>(&self, buf: &mut B) -> usize {
        // å°† key å®Œæ•´å†™å…¥ value éƒ¨åˆ†ï¼ˆç¬¬äºŒæ¬¡å­˜å‚¨ï¼‰
        buf.put_slice(&self.key[..]);  // â† 32 å­—èŠ‚çš„ key
        self.value.to_compact(buf) + 32  // â† å‹ç¼©çš„ value
    }

    fn from_compact(buf: &[u8], len: usize) -> (Self, &[u8]) {
        // ä» value éƒ¨åˆ†è¯»å– keyï¼ˆç¬¬äºŒæ¬¡è¯»å–ï¼‰
        let key = B256::from_slice(&buf[..32]);
        let (value, out) = U256::from_compact(&buf[32..], len - 32);
        (Self { key, value }, out)
    }
}
```

### è®¾è®¡åŸå› è¯¦è§£

```
1ï¸âƒ£ æ•°æ®åº“æ€§èƒ½ï¼ˆæœ€é‡è¦ï¼‰
  â”œâ”€ SubKey ç”¨äº MDBX çš„å†…éƒ¨ B-tree ç´¢å¼•
  â”œâ”€ æ”¯æŒ O(log N) çš„ seek_by_key_subkey() æŸ¥æ‰¾
  â””â”€ å¿…é¡»ä¿æŒæœªå‹ç¼©ï¼Œå¦åˆ™æ— æ³•äºŒåˆ†æœç´¢

2ï¸âƒ£ æ•°æ®å®Œæ•´æ€§
  â”œâ”€ StorageEntry æ˜¯è‡ªåŒ…å«çš„æ•°æ®ç»“æ„
  â”œâ”€ è¯»å–åä¸éœ€è¦é¢å¤–çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
  â”œâ”€ å¯ä»¥ç‹¬ç«‹åºåˆ—åŒ–ã€ä¼ è¾“ã€ç¼“å­˜
  â””â”€ ä¸éœ€è¦è®°ä½"è¿™ä¸ª entry æ˜¯ä»å“ªä¸ª SubKey è¯»å–çš„"

3ï¸âƒ£ ç¼–è§£ç ç®€åŒ–
  â”œâ”€ ååºåˆ—åŒ–æ—¶åªéœ€è¦ buf å‚æ•°
  â”œâ”€ ä¸éœ€è¦ (subkey, buf) ä¸¤ä¸ªå‚æ•°
  â””â”€ API æ›´ç®€æ´ï¼šStorageEntry::from_compact(buf)

4ï¸âƒ£ ç±»å‹ä¸€è‡´æ€§
  â”œâ”€ StorageEntry åœ¨ä¸åŒåœºæ™¯ä¸‹ä¿æŒç›¸åŒç»“æ„
  â”‚   â”œâ”€ PlainStorageStateï¼ˆSubKey = keyï¼‰
  â”‚   â”œâ”€ StorageChangeSetsï¼ˆSubKey â‰  keyï¼‰
  â”‚   â””â”€ å†…å­˜ BundleStateï¼ˆæ—  SubKeyï¼‰
  â””â”€ ç»Ÿä¸€çš„æ•°æ®æ¨¡å‹ï¼Œç®€åŒ–ä»£ç é€»è¾‘

5ï¸âƒ£ éªŒè¯å’Œè°ƒè¯•
  â””â”€ å¯ä»¥éªŒè¯ SubKey == StorageEntry.key
     â””â”€ æ£€æµ‹æ•°æ®åº“æŸåæˆ–é€»è¾‘é”™è¯¯
```

### å­˜å‚¨å¼€é”€åˆ†æ

```rust
æ¯ä¸ªå­˜å‚¨æ¡ç›®çš„å®é™…å­˜å‚¨ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Address (Key)          : 20 bytes   â”‚  å…±äº«ï¼ˆå¤šä¸ªæ§½ï¼‰
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ B256 (SubKey)          : 32 bytes   â”‚  â† ç¬¬ä¸€æ¬¡
â”‚ StorageEntry.key       : 32 bytes   â”‚  â† ç¬¬äºŒæ¬¡ï¼ˆå†—ä½™ï¼ï¼‰
â”‚ StorageEntry.value     : ~4-32 bytesâ”‚  å‹ç¼©å
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ€»è®¡ï¼ˆå•æ¡ç›®ï¼‰         : ~88 bytes  â”‚
â”‚ å†—ä½™                   : 32 bytes   â”‚
â”‚ å†—ä½™æ¯”ä¾‹               : ~36%       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å¯¹äº 1 ç™¾ä¸‡ä¸ªå­˜å‚¨æ§½ï¼š
â”œâ”€ å®é™…å­˜å‚¨ï¼š~88 MB
â”œâ”€ å†—ä½™å¼€é”€ï¼š~32 MB
â””â”€ å¦‚æœå»æ‰å†—ä½™ï¼š~56 MB

Trade-offï¼šç”¨ 36% çš„ç©ºé—´æ¢å–ï¼š
âœ… æ›´å¿«çš„æŸ¥è¯¢é€Ÿåº¦
âœ… æ›´ç®€æ´çš„ API
âœ… æ›´å¥½çš„æ•°æ®å®Œæ•´æ€§
```

### å®é™…ä»£ç éªŒè¯

```rust
// å†™å…¥å­˜å‚¨æ§½ï¼ˆcrates/storage/db/src/implementation/mdbx/mod.rs:745ï¼‰
let entry = StorageEntry {
    key: B256::with_last_byte(1),  // â† è¿™ä¸ª key
    value: U256::from(42),
};

// å†™å…¥ DupSort è¡¨
dup_cursor.upsert(address, &entry).unwrap();

// MDBX å®é™…å­˜å‚¨ï¼š
// 1. ç´¢å¼•å±‚ï¼šSubKey = 0x000...001 (32 bytes)
// 2. æ•°æ®å±‚ï¼šentry.key = 0x000...001 (32 bytes) â† ç›¸åŒå€¼ï¼

// è¯»å–æ—¶ï¼ˆcrates/storage/provider/src/providers/state/latest.rs:160ï¼‰
let mut cursor = tx.cursor_dup_read::<tables::PlainStorageState>()?;
if let Some(entry) = cursor.seek_by_key_subkey(address, storage_key)? {
    // entry.key == storage_key  // å§‹ç»ˆä¸º trueï¼
    // ä½† entry å¯ä»¥ç‹¬ç«‹ä½¿ç”¨ï¼Œæ— éœ€è®°ä½ storage_key
    println!("Value: {}", entry.value);
}
```

### æ€§èƒ½æƒè¡¡æ€»ç»“

```
âœ… ä¼˜ç‚¹ï¼š
  â”œâ”€ O(log N) æŸ¥æ‰¾æ€§èƒ½ï¼ˆMDBX B-treeï¼‰
  â”œâ”€ ç®€åŒ–çš„ APIï¼ˆæ— éœ€ä¼ é€’å¤–éƒ¨ keyï¼‰
  â”œâ”€ æ•°æ®è‡ªåŒ…å«ï¼ˆæ˜“äºç¼“å­˜å’Œä¼ è¾“ï¼‰
  â”œâ”€ ç±»å‹ç»Ÿä¸€ï¼ˆä¸åŒåœºæ™¯å¤ç”¨ç›¸åŒç»“æ„ï¼‰
  â””â”€ éªŒè¯èƒ½åŠ›ï¼ˆSubKey vs entry.keyï¼‰

âŒ ç¼ºç‚¹ï¼š
  â”œâ”€ 36% å­˜å‚¨ç©ºé—´å¼€é”€
  â”œâ”€ å†™å…¥æ—¶éœ€è¦ä¸¤æ¬¡å†™å…¥ç›¸åŒçš„ key
  â””â”€ åˆå­¦è€…å¯èƒ½æ„Ÿåˆ°å›°æƒ‘
```

### ä¸ºä»€ä¹ˆä¸ä¼˜åŒ–æ‰å†—ä½™ï¼Ÿ

**ä»£ç æ³¨é‡Šç»™å‡ºäº†ç­”æ¡ˆ**ï¼š

> If we have compression over whole value (Even SubKey) that would mess up fetching of values with seek_by_key_subkey

**åŸå› **ï¼š
1. **MDBX çš„ `seek_by_key_subkey` éœ€è¦ SubKey ç‹¬ç«‹å­˜åœ¨**ï¼Œç”¨äºäºŒåˆ†æœç´¢
2. å¦‚æœå°† key ä» `StorageEntry` ä¸­ç§»é™¤ï¼Œååºåˆ—åŒ–æ—¶éœ€è¦é¢å¤–ä¼ é€’ SubKey å‚æ•°
3. è¿™ä¼šå¯¼è‡´ API å¤æ‚åŒ–ï¼š`StorageEntry::from_compact(buf, subkey)` è€Œä¸æ˜¯ `from_compact(buf)`
4. ä¸åŒåœºæ™¯ä¸‹çš„ `StorageEntry` å°†æ— æ³•ç»Ÿä¸€ï¼ˆæœ‰äº›æœ‰ SubKeyï¼Œæœ‰äº›æ²¡æœ‰ï¼‰

**ç»“è®º**ï¼šè¿™æ˜¯ä¸€ä¸ªç»è¿‡æ·±æ€ç†Ÿè™‘çš„æƒè¡¡ï¼Œç”¨é€‚é‡çš„å­˜å‚¨å¼€é”€æ¢å–æ›´å¥½çš„æ€§èƒ½å’Œæ›´ç®€æ´çš„ä»£ç ï¼

---

**æœ€ç»ˆç»“è®º**: ä½ å¯¹å­˜å‚¨æ§½çš„ç†è§£**åœ¨æ¦‚å¿µå±‚é¢å®Œå…¨æ­£ç¡®**ï¼`(address, key, value)` ä¸‰å…ƒç»„ç¡®å®æ˜¯ç†è§£ä»¥å¤ªåŠå­˜å‚¨çš„æ­£ç¡®æ¨¡å‹ã€‚

**å…³é”®è¡¥å……**ï¼š
1. æ¯ä¸ªå­˜å‚¨æ§½çš„ `value` **æ°¸è¿œä¸ä¼šè¶…è¿‡ 256 ä½**ï¼Œè¿™æ˜¯ EVM æ¶æ„çš„åŸºæœ¬çº¦æŸ
2. `B256` çš„ `key` **ç¡®å®è¢«å­˜å‚¨äº†ä¸¤æ¬¡**ï¼ˆSubKey + StorageEntry.keyï¼‰ï¼Œè¿™æ˜¯æ€§èƒ½ä¸ç®€æ´æ€§çš„æƒè¡¡
3. Reth çš„å®é™…å®ç°å®Œç¾ä½“ç°äº†è¿™äº›è®¾è®¡å†³ç­–ï¼ğŸ¯

---

## ğŸ“¦ ç‰¹åˆ«æ¡ˆä¾‹ï¼šbytes å’Œ string åŠ¨æ€é•¿åº¦ç±»å‹

### é—®é¢˜ï¼šå¦‚æœæ•°æ®è¶…è¿‡ 256 ä½æ€ä¹ˆåŠï¼Ÿ

è™½ç„¶**å•ä¸ªå­˜å‚¨æ§½é™åˆ¶ä¸º 256 ä½**ï¼Œä½† Solidity çš„ `bytes` å’Œ `string` ç±»å‹å¯ä»¥å­˜å‚¨**ä»»æ„é•¿åº¦**çš„æ•°æ®ï¼

### ğŸ”‘ åŠ¨æ€ç±»å‹çš„å­˜å‚¨ç­–ç•¥

Solidity ä½¿ç”¨ä¸€ä¸ª**åˆ†æ®µå­˜å‚¨æœºåˆ¶**æ¥å¤„ç†åŠ¨æ€é•¿åº¦æ•°æ®ï¼š

```solidity
contract DynamicStorage {
    bytes public data;  // å¯ä»¥æ˜¯ä»»æ„é•¿åº¦ï¼
    
    // åœºæ™¯ 1ï¼šçŸ­æ•°æ® (â‰¤ 31 å­—èŠ‚)
    function setShort(bytes memory _data) public {
        data = hex"48656c6c6f";  // "Hello" (5 å­—èŠ‚)
    }
    
    // åœºæ™¯ 2ï¼šé•¿æ•°æ® (â‰¥ 32 å­—èŠ‚)
    function setLong(bytes memory _data) public {
        data = new bytes(100);  // 100 å­—èŠ‚
    }
}
```

### ğŸ“ å­˜å‚¨è§„åˆ™ï¼šçŸ­æ•°æ® vs é•¿æ•°æ®

```
è§„åˆ™åˆ†ç•Œçº¿ï¼š31 å­—èŠ‚

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ•°æ®é•¿åº¦ â‰¤ 31 å­—èŠ‚ï¼šå•æ§½å­˜å‚¨          â”‚
â”‚ æ•°æ®é•¿åº¦ â‰¥ 32 å­—èŠ‚ï¼šå¤šæ§½å­˜å‚¨          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ åœºæ™¯ 1ï¼šçŸ­æ•°æ®å­˜å‚¨ (â‰¤ 31 å­—èŠ‚)

### å•æ§½ä¼˜åŒ–å­˜å‚¨

```solidity
contract ShortBytes {
    bytes public name = "Alice";  // 5 å­—èŠ‚
    //                    ^^^^^ çŸ­æ•°æ®
    
    // æ§½ä½ï¼šå‡è®¾ name åœ¨ slot 0
}
```

### å­˜å‚¨å¸ƒå±€

```
Slot 0 çš„ 256 ä½ (32 å­—èŠ‚):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [0:5]   : "Alice" (å®é™…æ•°æ®)                     â”‚  5 å­—èŠ‚
â”‚ [5:31]  : 0x00... (å¡«å……é›¶)                       â”‚  26 å­—èŠ‚
â”‚ [31:32] : 0x0A (length * 2 = 5 * 2 = 10)        â”‚  1 å­—èŠ‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†‘                                    â†‘
   æ•°æ®æœ¬èº«                          é•¿åº¦ç¼–ç 

å®Œæ•´å€¼ (åå…­è¿›åˆ¶):
0x416c696365000000000000000000000000000000000000000000000000000a
  ^^^^^^^^                                                    ^^
  "Alice"                                                length*2
```

**ç¼–ç è§„åˆ™**ï¼š
- **ä½ä½å­—èŠ‚ [0:length]**ï¼šå®é™…æ•°æ®
- **é«˜ä½å­—èŠ‚ [length:31]**ï¼šå¡«å……é›¶
- **æœ€åä¸€ä¸ªå­—èŠ‚ [31]**ï¼š`length * 2`ï¼ˆå¶æ•°è¡¨ç¤ºçŸ­æ•°æ®ï¼‰

---

## ğŸŒ åœºæ™¯ 2ï¼šé•¿æ•°æ®å­˜å‚¨ (â‰¥ 32 å­—èŠ‚)

### å¤šæ§½åˆ†æ®µå­˜å‚¨

```solidity
contract LongBytes {
    bytes public data;  // å‡è®¾åœ¨ slot 0
    
    function setLongData() public {
        data = new bytes(100);  // 100 å­—èŠ‚çš„æ•°æ®
        // å¡«å……ä¸€äº›æ•°æ®
        for (uint i = 0; i < 100; i++) {
            data[i] = bytes1(uint8(i));
        }
    }
}
```

### å­˜å‚¨å¸ƒå±€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Slot 0 (ä¸»æ§½):                                   â”‚
â”‚   å­˜å‚¨é•¿åº¦ä¿¡æ¯: length * 2 + 1                   â”‚
â”‚   = 100 * 2 + 1 = 201 (0xC9)                    â”‚
â”‚   (å¥‡æ•°è¡¨ç¤ºé•¿æ•°æ®)                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
        è®¡ç®—æ•°æ®æ§½èµ·å§‹ä½ç½®
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Data Slot Base = keccak256(0)                   â”‚
â”‚   (å¯¹ä¸»æ§½ç¼–å·è¿›è¡Œå“ˆå¸Œ)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ keccak256(0) + 0: bytes[0:32]    (32 å­—èŠ‚)      â”‚  Slot 1
â”‚ keccak256(0) + 1: bytes[32:64]   (32 å­—èŠ‚)      â”‚  Slot 2
â”‚ keccak256(0) + 2: bytes[64:96]   (32 å­—èŠ‚)      â”‚  Slot 3
â”‚ keccak256(0) + 3: bytes[96:100]  (4 å­—èŠ‚ + å¡«å……)â”‚  Slot 4
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ€»å…±ä½¿ç”¨ï¼š1 (ä¸»æ§½) + 4 (æ•°æ®æ§½) = 5 ä¸ªå­˜å‚¨æ§½
```

### è¯¦ç»†ç¼–ç 

```rust
ä¸»æ§½ (Slot 0):
  Value: 0x00...00C9
         ^^^^^^^^ (100 * 2 + 1 = 201)
         æœ€ä½ä½ = 1 (å¥‡æ•°) â†’ è¡¨ç¤ºé•¿æ•°æ®

æ•°æ®æ§½èµ·å§‹ä½ç½®è®¡ç®—ï¼š
  base = keccak256(abi.encode(0))  // å¯¹æ§½ä½ç¼–å·å“ˆå¸Œ
       = 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563

æ•°æ®æ§½åˆ†é…ï¼š
  Slot base + 0: 0x000102030405...1F (bytes[0:32])
  Slot base + 1: 0x202122232425...3F (bytes[32:64])
  Slot base + 2: 0x404142434445...5F (bytes[64:96])
  Slot base + 3: 0x60616263000...00 (bytes[96:100] + padding)
```

---

## ğŸ§® åŠ¨æ€ç±»å‹æ§½ä½è®¡ç®—å…¬å¼

### é€šç”¨è§„åˆ™

```solidity
// å‡è®¾åŠ¨æ€å˜é‡åœ¨ slot p

// 1. ä¸»æ§½å†…å®¹
if (data.length <= 31) {
    // çŸ­æ•°æ®ï¼šå•æ§½å­˜å‚¨
    slot[p] = data || (length * 2)
    //        ^^^^    ^^^^^^^^^^^
    //       æ•°æ®      é•¿åº¦æ ‡è®° (æœ€åä¸€ä¸ªå­—èŠ‚)
} else {
    // é•¿æ•°æ®ï¼šå¤šæ§½å­˜å‚¨
    slot[p] = length * 2 + 1
    //                   ^
    //                  å¥‡æ•°æ ‡è®°
}

// 2. æ•°æ®æ§½ä½ç½®ï¼ˆé•¿æ•°æ®ï¼‰
base_slot = keccak256(p)
data_slot_i = base_slot + i  // i = 0, 1, 2, ...
```

### å®é™…ä¾‹å­

```solidity
contract Example {
    uint256 public a;     // slot 0
    bytes public data;    // slot 1 (ä¸»æ§½)
    uint256 public b;     // slot 2
}

// è®¾ç½® data = new bytes(100)

// å­˜å‚¨å¸ƒå±€ï¼š
// Slot 0: a çš„å€¼
// Slot 1: 0x00...C9 (100 * 2 + 1 = 201)
// Slot 2: b çš„å€¼
// Slot keccak256(1) + 0: data[0:32]
// Slot keccak256(1) + 1: data[32:64]
// Slot keccak256(1) + 2: data[64:96]
// Slot keccak256(1) + 3: data[96:100]
```

---

## ğŸ’° Gas æˆæœ¬åˆ†æ

### çŸ­æ•°æ® vs é•¿æ•°æ®

```solidity
contract GasComparison {
    bytes public shortData;  // slot 0
    bytes public longData;   // slot 1
    
    // åœºæ™¯ 1ï¼šå­˜å‚¨ 31 å­—èŠ‚ï¼ˆçŸ­æ•°æ®ï¼‰
    function setShort() public {
        shortData = new bytes(31);
        // Gas æˆæœ¬ï¼š~20,000 (é¦–æ¬¡å†™å…¥)
        // åªå†™å…¥ 1 ä¸ªæ§½
    }
    
    // åœºæ™¯ 2ï¼šå­˜å‚¨ 100 å­—èŠ‚ï¼ˆé•¿æ•°æ®ï¼‰
    function setLong() public {
        longData = new bytes(100);
        // Gas æˆæœ¬ï¼š~100,000 (é¦–æ¬¡å†™å…¥)
        // å†™å…¥ï¼š1 (ä¸»æ§½) + 4 (æ•°æ®æ§½) = 5 ä¸ªæ§½
        // æ¯ä¸ªæ§½ 20,000 gas
    }
}
```

### æˆæœ¬æ˜ç»†

```
æ“ä½œ            | æ§½æ•° | Gas æˆæœ¬ (é¦–æ¬¡) | Gas æˆæœ¬ (æ›´æ–°)
---------------|------|----------------|----------------
31 å­—èŠ‚ (çŸ­)   | 1    | 20,000         | 5,000
32 å­—èŠ‚ (é•¿)   | 2    | 40,000         | 10,000
64 å­—èŠ‚        | 3    | 60,000         | 15,000
100 å­—èŠ‚       | 5    | 100,000        | 25,000
1000 å­—èŠ‚      | 33   | 660,000        | 165,000

ç»“è®ºï¼šé•¿æ•°æ®éå¸¸æ˜‚è´µï¼
```

---

## ğŸ” åœ¨ Reth ä¸­çš„ä½“ç°

### è¯»å–åŠ¨æ€æ•°æ®

```rust
// å‡è®¾æˆ‘ä»¬è¦è¯»å– PlainStorageState ä¸­çš„é•¿ bytes æ•°æ®

// 1. è¯»å–ä¸»æ§½ï¼Œè·å–é•¿åº¦
let main_slot = B256::from(slot_number);
let length_encoded = provider.storage(address, main_slot)?;

if length_encoded.byte(31) & 1 == 1 {
    // é•¿æ•°æ®ï¼šæœ€ä½ä½ä¸ºå¥‡æ•°
    let length = (length_encoded.to::<usize>() - 1) / 2;
    
    // 2. è®¡ç®—æ•°æ®æ§½èµ·å§‹ä½ç½®
    let base_slot = keccak256(slot_number.to_be_bytes());
    
    // 3. è¯»å–æ‰€æœ‰æ•°æ®æ§½
    let num_slots = (length + 31) / 32;  // å‘ä¸Šå–æ•´
    let mut data = Vec::new();
    
    for i in 0..num_slots {
        let data_slot = B256::from(U256::from_be_bytes(base_slot.0) + U256::from(i));
        let chunk = provider.storage(address, data_slot)?;
        data.extend_from_slice(&chunk[..]);
    }
    
    data.truncate(length);  // æˆªæ–­åˆ°å®é™…é•¿åº¦
} else {
    // çŸ­æ•°æ®ï¼šç›´æ¥ä»ä¸»æ§½è¯»å–
    let length = length_encoded.byte(31) / 2;
    let data = &length_encoded[..length];
}
```

### å®é™…æ•°æ®åº“æŸ¥è¯¢

```rust
// åœ¨ Reth çš„ PlainStorageState è¡¨ä¸­ï¼š

// åˆçº¦åœ°å€ï¼š0x1234...
// ä¸»æ§½ (slot 5): å­˜å‚¨ bytes å˜é‡çš„é•¿åº¦ä¿¡æ¯

// æŸ¥è¯¢ 1ï¼šè¯»å–ä¸»æ§½
let main_entry = cursor.seek_by_key_subkey(
    address,
    B256::from(U256::from(5))  // slot 5
)?;
// main_entry.value = U256::from(201)  // é•¿æ•°æ®æ ‡è®°

// æŸ¥è¯¢ 2-5ï¼šè¯»å–æ•°æ®æ§½
let base = keccak256(&5u64.to_be_bytes());
for i in 0..4 {
    let data_slot = B256::from(U256::from_be_bytes(base.0) + U256::from(i));
    let data_entry = cursor.seek_by_key_subkey(address, data_slot)?;
    // data_entry.value åŒ…å« 32 å­—èŠ‚çš„æ•°æ®å—
}
```

---

## ğŸ“Š å®æˆ˜ç¤ºä¾‹ï¼šå­˜å‚¨å’Œè¯»å–é•¿ bytes

### Solidity åˆçº¦

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BytesStorage {
    bytes public data;  // slot 0
    
    // è®¾ç½®é•¿æ•°æ®
    function setLongData(bytes memory _data) public {
        data = _data;
    }
    
    // è·å–æ•°æ®é•¿åº¦
    function getLength() public view returns (uint256) {
        return data.length;
    }
    
    // è·å–ç‰¹å®šå­—èŠ‚
    function getByte(uint256 index) public view returns (bytes1) {
        require(index < data.length, "Index out of bounds");
        return data[index];
    }
}
```

### è°ƒç”¨ç¤ºä¾‹

```javascript
// JavaScript (ethers.js)
const data = new Uint8Array(100).fill(0x42);  // 100 å­—èŠ‚çš„ 0x42
await contract.setLongData(data);

// å­˜å‚¨å¸ƒå±€ï¼š
// Slot 0: 0x00...C9 (length * 2 + 1 = 201)
// Slot keccak256(0) + 0: 0x42424242... (32 bytes)
// Slot keccak256(0) + 1: 0x42424242... (32 bytes)
// Slot keccak256(0) + 2: 0x42424242... (32 bytes)
// Slot keccak256(0) + 3: 0x42424242... (4 bytes + padding)
```

### Foundry æµ‹è¯•éªŒè¯

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "./BytesStorage.sol";

contract BytesStorageTest is Test {
    BytesStorage public store;
    
    function setUp() public {
        store = new BytesStorage();
    }
    
    function testLongBytesStorage() public {
        // åˆ›å»º 100 å­—èŠ‚çš„æ•°æ®
        bytes memory longData = new bytes(100);
        for (uint i = 0; i < 100; i++) {
            longData[i] = bytes1(uint8(i));
        }
        
        // å­˜å‚¨
        store.setLongData(longData);
        
        // éªŒè¯é•¿åº¦
        assertEq(store.getLength(), 100);
        
        // éªŒè¯ä¸»æ§½ï¼ˆslot 0ï¼‰
        uint256 mainSlot = uint256(vm.load(address(store), bytes32(uint256(0))));
        assertEq(mainSlot, 201);  // 100 * 2 + 1
        
        // éªŒè¯æ•°æ®æ§½
        bytes32 baseSlot = keccak256(abi.encode(0));
        for (uint i = 0; i < 4; i++) {
            bytes32 dataSlot = bytes32(uint256(baseSlot) + i);
            bytes32 value = vm.load(address(store), dataSlot);
            // éªŒè¯æ•°æ®å†…å®¹
            console.logBytes32(value);
        }
    }
}
```

---

## ğŸ¯ å…³é”®è¦ç‚¹æ€»ç»“

### åŠ¨æ€ç±»å‹å­˜å‚¨è§„åˆ™

```
1ï¸âƒ£ å•æ§½é™åˆ¶ä¾ç„¶å­˜åœ¨
  â””â”€ æ¯ä¸ªæ§½åªèƒ½å­˜å‚¨ 256 ä½

2ï¸âƒ£ åŠ¨æ€ç±»å‹çš„è§£å†³æ–¹æ¡ˆ
  â””â”€ çŸ­æ•°æ® (â‰¤31 å­—èŠ‚): å•æ§½ä¼˜åŒ–å­˜å‚¨
  â””â”€ é•¿æ•°æ® (â‰¥32 å­—èŠ‚): å¤šæ§½åˆ†æ®µå­˜å‚¨

3ï¸âƒ£ æ§½ä½è®¡ç®—
  â””â”€ ä¸»æ§½ï¼šå­˜å‚¨é•¿åº¦ä¿¡æ¯
  â””â”€ æ•°æ®æ§½ï¼škeccak256(ä¸»æ§½ç¼–å·) + ç´¢å¼•

4ï¸âƒ£ Gas æˆæœ¬
  â””â”€ æ¯ 32 å­—èŠ‚ â‰ˆ 20,000 gas (é¦–æ¬¡)
  â””â”€ é•¿æ•°æ®å­˜å‚¨éå¸¸æ˜‚è´µï¼

5ï¸âƒ£ åœ¨ Reth ä¸­
  â””â”€ æ¯ä¸ªæ§½ä¾ç„¶æ˜¯ç‹¬ç«‹çš„ StorageEntry
  â””â”€ éœ€è¦å¤šæ¬¡æŸ¥è¯¢æ¥é‡ç»„é•¿æ•°æ®
  â””â”€ åº”ç”¨å±‚è´Ÿè´£ç»„è£…
```

### ä¼˜åŒ–å»ºè®®

```
âœ… å°½é‡ä½¿ç”¨çŸ­æ•°æ®ï¼ˆâ‰¤31 å­—èŠ‚ï¼‰
âœ… è€ƒè™‘ä½¿ç”¨ bytes32 ä»£æ›¿ bytesï¼ˆå›ºå®šé•¿åº¦ï¼‰
âœ… é¿å…å­˜å‚¨å¤§æ–‡ä»¶ï¼ˆä½¿ç”¨ IPFS ç­‰é“¾ä¸‹å­˜å‚¨ï¼‰
âœ… ä½¿ç”¨äº‹ä»¶ (events) è®°å½•æ—¥å¿—è€Œéå­˜å‚¨
âœ… å‹ç¼©æ•°æ®å†å­˜å‚¨

âŒ é¿å…åœ¨é“¾ä¸Šå­˜å‚¨å¤§é‡æ•°æ®
âŒ é¿å…é¢‘ç¹ä¿®æ”¹é•¿ bytes
âŒ é¿å…åŠ¨æ€å¢é•¿çš„ bytes
```

### æ¶æ„å±‚é¢çš„ç†è§£

```
EVM å­˜å‚¨å±‚æ¬¡ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åº”ç”¨å±‚ (Solidity)                   â”‚
â”‚  â”œâ”€ bytes (åŠ¨æ€é•¿åº¦æŠ½è±¡)            â”‚
â”‚  â””â”€ string (åŠ¨æ€é•¿åº¦æŠ½è±¡)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ ç¼–è¯‘å™¨å¤„ç†
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å­˜å‚¨å±‚ (EVM)                        â”‚
â”‚  â”œâ”€ ä¸»æ§½ (é•¿åº¦ä¿¡æ¯)                 â”‚
â”‚  â””â”€ æ•°æ®æ§½é“¾ (keccak256 + ç´¢å¼•)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ æ¯ä¸ªæ§½
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç‰©ç†å±‚ (Reth/MDBX)                  â”‚
â”‚  â””â”€ æ¯æ§½ = ç‹¬ç«‹ StorageEntry        â”‚
â”‚     â””â”€ key: B256, value: U256      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç»“è®ºï¼š256 ä½é™åˆ¶åœ¨ç‰©ç†å±‚ï¼ŒåŠ¨æ€ç±»å‹åœ¨åº”ç”¨å±‚ï¼
```

---

**å›ç­”ä½ çš„é—®é¢˜**ï¼šå¦‚æœ Solidity åˆçº¦ä¸­æœ‰ä¸€ä¸ª `bytes` ç±»å‹çš„å˜é‡ç‰¹åˆ«é•¿ï¼ŒEVM ä¼šï¼š

1. **å°†é•¿åº¦ä¿¡æ¯å­˜å‚¨åœ¨ä¸»æ§½**ï¼ˆç¼–ç ä¸º `length * 2 + 1`ï¼‰
2. **å°†æ•°æ®åˆ†æ®µå­˜å‚¨åœ¨è¿ç»­çš„æ§½ä¸­**ï¼ˆèµ·å§‹ä½ç½® = `keccak256(ä¸»æ§½ç¼–å·)`ï¼‰
3. **æ¯ä¸ªæ•°æ®æ§½ä¾ç„¶åªèƒ½å­˜å‚¨ 32 å­—èŠ‚**
4. **Reth åœ¨æ•°æ®åº“ä¸­ä¸ºæ¯ä¸ªæ§½åˆ›å»ºç‹¬ç«‹çš„ `StorageEntry`**
5. **åº”ç”¨å±‚è´Ÿè´£å°†å¤šä¸ªæ§½é‡ç»„æˆå®Œæ•´æ•°æ®**

è¿™æ ·æ—¢ä¿æŒäº† 256 ä½æ§½çš„åŸºæœ¬é™åˆ¶ï¼Œåˆå®ç°äº†ä»»æ„é•¿åº¦æ•°æ®çš„å­˜å‚¨ï¼ğŸ¯
